# CREATION DE L'APPLICATION DANS DOCKER COMPOSE:
# On va d'abord créer notre application avec Docker:
git clone https://github.com/Azure-Samples/aks-store-demo.git
cd aks-store-demo
# Parcourez (en l'ouvrant avec cat) le fichier Docker Compose docker-compose-quickstart.yml pour voir ce que contient l'application:
cat docker-compose-quickstart.yml
# Création de l'image du conteneur, téléchargement de l'image Redis, et démarrage de l'application avec Compose:
docker compose -f docker-compose-quickstart.yml up -d
# Vérification de la présence des images:
docker images
# Visualisation des conteneurs en cours d'exécution:
docker ps
(# POUR INFO, NE PAS EXECUTER MAINTENANT: pour arrêter les conteneurs: docker compose down)
(# A noter qu'il est possible de tester l'application sur un environnement LOCAL en la lançant avec Docker Compose et en se connectant à http://localhost:8080)

# CREATION DU REGISTRE DE CONTENEURS:
# Création du groupe de ressources:
az group create --name myResourceGroup --location eastus
# D'acord créer un registre ACR via le portail (alternative: voir support de formation pour la création via l'interface graphique):
# Astuce: pour remplacer automatiquement $ACRNAME par le nom de votre registre dans la suite du code:
ACRNAME='nom_de_mon_registre'
az acr create --resource-group myResourceGroup --name $ACRNAME --sku Basic
# Build et push des images de l'application vers le registre ACR:
az acr build --registry $ACRNAME --image aks-store-demo/product-service:latest ./src/product-service/
az acr build --registry $ACRNAME --image aks-store-demo/order-service:latest ./src/order-service/
az acr build --registry $ACRNAME --image aks-store-demo/store-front:latest ./src/store-front/
# Vérification:
az acr repository list --name $ACRNAME --output table


# CREATON DU CLUSTER AKS:
# Ensuite, créer le cluster AKS remplacer <acrName> par le nom de votre ACR):
az aks create --resource-group myResourceGroup --name myAKSCluster --node-count 2 --generate-ssh-keys --attach-acr <acrName>
# Puis on configure kubectl pour qu'il se connecte à notre cluster avec get-credentials:
az aks get-credentials --resource-group myResourceGroup --name myAKSCluster
# Vérifions la connexion du cluster aux noeuds:
kubectl get nodes

# MISE A JOUR DES URL DES IMAGES DANS LE MANIFESTE:
# Afin de déployer l'application, nous avons besoin de récupérer le nom du serveur de login (nota: il est aussi possible de le récupérer via l'interface graphique en allant dans la ressource ACR):
az acr list --resource-group myResourceGroup --query "[].{acrLoginServer:loginServer}" --output table
# Aller dans le répertoire ask-store-demo où se trouve le manifeste K8s, et l'ouvrir avec nano ou vi:
nano aks-store-quickstart.yaml
# Remplacer dans les lignes 91, 157, et 199, la chaine de caractère 'ghcr.io/azure-samples' par 'aksmt23.azurecr.io' dans l'URL de l'image. Voici un extrait du code concerné:
containers:
...
- name: order-service
 image: ghcr.io/azure-samples.azurecr.io/aks-store-demo/order-service:latest
...
- name: product-service
 image: ghcr.io/azure-samples.azurecr.io/aks-store-demo/product-service:latest
...
- name: store-front
 image: ghcr.io/azure-samples.azurecr.io/aks-store-demo/store-front:latest
...

# DEPLOIEMENT DE L'APPLICATION:
kubectl apply -f aks-store-quickstart.yaml
# Vous devriez voir en output que chacun des srvices est déployé et créé.

# TEST DE L'APPLICATION:
# K8s expose l'application via l'URL publique au bout de quelques secondes ou minutes. Pour surveiller en temps réel sa disponibilité publique (Nota: --watch suspend le terminal):
kubectl get service store-front --watch
# Initialement l'affichage ressemblera à ceci (à noter l'état 'pending'):
store-front   LoadBalancer   10.0.34.242   <pending>     80:30676/TCP   5s
# Puis l'adresse IP finale devrait apparaitre à la place de 'pending':
store-front   LoadBalancer   10.0.34.242   52.179.23.131   80:30676/TCP   67s

# On peut visualiser les pods:
kubectl get pods
